- 后端优化
1. 硬件升级
2. 缓存化
3. 产品逻辑优化
- 拦截无效流量
4. 服务化
5. 异步化
6. 搜索引擎

- 代码调优

- 数据库调优
1. sql调用
* MySQL为例，最常见的方式是，由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用explain、profile等工具来逐步调优，最后经过测试达到效果后上线。

* 查询优化：避免全表扫描
对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。	
避免通配符紧随like出现，如LIKE ‘%ABC’
避免在WHERE子句中使用IS NULL
避免使用不等于：!= , <>
避免使用OR否则将导致引擎放弃使用索引而进行全表扫描, 尽量使用UNION ALL
尽量用EXIST子查询代替IN子程序否则会导致全表扫描
避免只给出复合索引中的其中一个字段
避免WHERE 1=1这样的写法
避免在WHERE子句中对字段进行表达式操作，如WHERE num/2=100
避免在WHERE子句中对字段进行函数操作，如SUBSTR(name，1，2)=‘ab’
在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，	
否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率
* 建表优化
尽可能使用数字型字段
尽量使用varchar代替char，节省存储空间
* 其他优化
除非查询所有字段，否则应避免使用SELECT *
* 基数（CARDINALITY）
某个列唯一键（Distinct_Keys）的数量叫作基数。比如性别列，该列只有男女之分，所以这一列基数是2。
主键列的基数等于表的总行数。基数的高低影响列的数据分布。
* 选择性（SELECTIVITY）
基数与总行数的比值再乘以100%就是某个列的选择性。
当一个列出现在where条件中，该列没有创建索引并且选择性大于20%，那么该列就必须创建索引，从而提升SQL查询性能

2. 架构层次调用
读写分离、多从库负载均衡、水平和垂直分库分表
3. 连接池调优

- 缓存
1. 本地缓存（hashmap）和缓存服务（redis）使用场景
如果数据量小，并且不会频繁地增长又清空（这会导致频繁地垃圾回收），那么可以选择本地缓存。
其他情况，可以考虑缓存服务。
2. 缓存满了怎么办
* 给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU
* 针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。
* 给一些没有必要长期保存的key，尽量设置过期时间。
3. 缓存是否允许丢失
Redis的RDB或者AOF,持久化˙


