# 选择排序 （Selection sort）
选出队列最小的值，放在起始，n²，不稳定



# 满二叉树和完全二叉树。
满二叉树是叶节点全满的二叉树
完全二叉树是除了叶节点都满，而且先左节点后有节点的二叉树

# 二叉查询树 binary search tree
1. 左节点的值都小于等于他父节点的值
2. 右节点的值都大于等于他父节点的值
3. 左右子树也都是二叉查询树
缺点：如果插入值一直是越来越小，那这颗树就是左边线性🌲


# 红黑树原理
满足一个树是红黑树条件：

1. 每个节点要么是红色，要么是黑色。Every node is either red or black.
2. 根节点必须是黑色The root is black.
3. Every leaf (NIL) is black
4. 从任意节点出发，到其所有叶子节点的简单路径上都包含相同数目的黑色节点.（非常重要）
For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.
5. 每个红色节点的两个子节点一定都是黑色（叶子节点包含NULL）f a node is red, then both its children are black

红黑树 优势
红黑树能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。这一点是AVL所不具备的

左旋：
自己是父亲的右下，互换，自己的左下变成父亲的右下
右旋：
自己是父亲左下，互换，自己的右下变成父亲的左下


# B tree 又叫平衡多路查找树

一个M阶的B-树有以下基本性质：
1）每个节点至多有M个子节点；
2）有K个子节点的非叶子节点中包含K-1个键（Key）;
3）根节点至少有两个子节点（如果此时B-树不仅只有根节点）；
4）每个非叶子节点（根节点除外）至少有Ceil[M/2]个子节点；这里Ceil表示向上取整；
5）所有的叶子节点都在同一层。
关键字
1. ceil【M/2】-1<= n<= m-1 
2. 关键字升序排列
3. P[i] 指向（K[i-1]-K[i]）


# B+tree

* B+树与B树的不同在于：
（1）所有关键字存储在叶子节点，非叶子节点不存储真正的data
（2）为所有叶子节点增加了一个链指针
* 为什么用B/B+树这种结构来实现索引呢
假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3，也即索引的B+树层次一般不超过三层，所以查找效率很高）。
而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。
* 为什么mysql的索引使用B+树而不是B树呢？？
B+树更适合外部存储(一般指磁盘存储),由于内节点(非叶子节点)不存储data，所以一个节点可以存储更多的内节点,也就是说使用B+树单次磁盘IO的信息量相比较B树更大，IO效率更高。
经常会按照区间来访问某个索引列，B+树的叶子节点间按顺序建立了链指针，加强了区间访问性