
# 选择排序（Selection sort）：O(n²)，不稳定
选择排序（Selection sort）是一种简单直观的排序算法。
它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。
以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。

# 冒泡排序 （Bubble sort）：O(n²) 到 O(n),稳定 , 基本不用，太慢
适用元素较少的情况下，
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
5. 4种基本实现
   + 普通遍历
   + 设置一个标志位，当没有交换的时候这个标志位不会变化，那么说明数据已经排序好了
   + 记录最后互换那个位置，然后从头到这个位置再排序
   + 鸡尾酒排序，双向扫描 ， 记录最后一个交换的位置，从最后一个交换位置处从下向上扫描，再记录最后一个交换的位置，从最后一个交换位置处从上向下扫描

# 插入排序 （Insertion sort）:稳定 O(n²) 到O(n)
每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。
对于基本有序的数组是最好用的
1. 把一个位置的数字和前面比较，（找到比他小的，与他交换）或者比他小就交换
2. 把一个需要排序的记录temp，然后比他大的之前的往后诺一位 (直接排序straight insertion sort)
3. 折半插入排序（binary insertion sort）是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度

# 2分插入 binary Insertion sort 折半插入排序
折半插入排序算法是一种稳定的排序算法，比直接插入算法明显减少了关键字之间比较的次数，因此速度比直接插入排序算法快，但记录移动的次数没有变

# 希尔排序 非稳定 O(n²)
改进过的插入排序，缩小增量排序
间隔大移动次数少，间隔小移动距离段
 
# 归并排序 (merge sort) 稳定 O(nlogn)	T(n)	
归并排序的核心思想是将两个有序的数列合并成一个大的有序的序列。通过递归，层层合并，即为归并。

# TimSort 最好 O(n)	
merge sort + binary sort 


# 快速排序 quick search O(n*log(n))
快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
